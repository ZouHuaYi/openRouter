# 限流机制说明文档

## 🎯 核心概念

### 两个独立的概念

#### 1. 限流规则（Cooldown Rule）
- **作用**：预先配置的限流时长规则
- **存储位置**：`config/providers.json` 中的 `backends` 数组
- **状态**：待用，不影响模型可用性
- **配置方式**：在"编辑后端"对话框中设置

#### 2. 限流状态（Cooldown State）
- **作用**：实际生效的限流状态
- **存储位置**：`config/backend-state.json`
- **状态**：生效中，模型不可用
- **触发方式**：手动点击"触发限流"按钮

---

## 📊 数据结构

### providers.json（限流规则）

```json
{
  "backends": [
    {
      "provider": "doubao",
      "model": "model-name",
      "cooldownRule": {
        "type": "preset",    // preset | hours | days
        "value": "day"       // day/week/month | 数字 | 数字
      }
    }
  ]
}
```

**字段说明**：
- `cooldownRule`：可选字段，存在表示配置了规则
- `type`：规则类型
  - `preset`：预设模式（天/周/月，0点解封）
  - `hours`：按小时（+3分钟缓冲）
  - `days`：按天数（精确计算）
- `value`：具体值
  - 预设模式：`day` / `week` / `month`
  - 小时模式：数字（如 `1`, `6`, `24`）
  - 天数模式：数字（如 `1`, `3`, `7`）

### backend-state.json（限流状态）

```json
{
  "doubao:model-name": {
    "unblockAt": "2026-02-07T00:00:00.000Z"
  }
}
```

**字段说明**：
- Key：`provider:model` 格式
- `unblockAt`：解封时间（ISO时间戳）
- 只有触发限流后才会有数据

---

## 🔄 完整流程

### 流程 1：配置限流规则

1. **点击"编辑"按钮**
   - 打开编辑对话框

2. **配置限流规则**
   - 开启"启用限流规则"开关
   - 选择限流类型（预设/小时/天数）
   - 设置具体参数

3. **保存配置**
   - 规则保存到 `providers.json` 的 `cooldownRule` 字段
   - **模型仍然显示"可用"状态**
   - 表格中"限流规则"列显示规则信息

### 流程 2：触发限流

**场景 A：模型被API限流**
1. 调用API，返回 429 或其他限流错误
2. 在表格中找到该模型
3. 点击"触发限流"按钮
4. 系统根据配置的规则计算解封时间
5. 保存到 `backend-state.json`
6. **模型状态变为"限流至 XX"**

**场景 B：手动触发**
1. 发现模型不可用（通过其他方式）
2. 点击"触发限流"按钮
3. 应用规则，状态变为限流

### 流程 3：解封

**自动解封**：
- 解封时间到达后，刷新页面
- `backendStatus()` 函数检测到时间已过
- 自动显示"可用"状态

**手动解封**：
- 点击"解封"按钮
- 清除 `backend-state.json` 中的数据
- 立即变为"可用"状态

---

## 🖥️ UI 界面说明

### 表格列

| 列名 | 说明 |
|------|------|
| 服务商 | 提供商名称 |
| 模型 | 模型 ID |
| **限流规则** | 显示配置的规则（如"预设：1天"、"2小时"、"3天"） |
| **当前状态** | "可用" 或 "限流至 XX" |
| **快速操作** | "触发限流"（可用时） / "解封"（限流时） |
| 排序 | 上移/下移 |
| 操作 | 编辑/删除 |

### 编辑对话框

```
┌─────────────────────────────────────┐
│ 编辑后端                            │
├─────────────────────────────────────┤
│ 服务商: [doubao ▼] (禁用)          │
│ 模型:   [model-xxx] (禁用)         │
│                                     │
│ ══════ 限流规则配置 ══════          │
│                                     │
│ [i] 说明：这里配置的是限流规则，    │
│     不会立即生效。当模型被限流时，  │
│     点击『触发限流』按钮应用规则。  │
│                                     │
│ 启用限流规则: [●───] 开             │
│                                     │
│ 限流类型:                           │
│   ⦿ 预设（0点解封）                 │
│   ○ 按小时（+3分钟）                │
│   ○ 按天数                          │
│                                     │
│ 预设时长: [1 天（0点解封）▼]       │
│                                     │
├─────────────────────────────────────┤
│              [取消]  [确定]         │
└─────────────────────────────────────┘
```

---

## 💡 使用场景

### 场景 1：预先配置规则

**背景**：
- 服务商每天限流 1000 次请求
- 每天 00:00 重置

**操作步骤**：
1. 编辑后端，配置规则：预设模式 - 1天
2. 保存（模型仍然可用）
3. 当 API 返回 429 错误时，点击"触发限流"
4. 模型自动在明天 00:00 解封

### 场景 2：临时封禁

**背景**：
- 发现某个模型质量不好
- 想临时封禁 3 天

**操作步骤**：
1. 编辑后端，配置规则：按天数 - 3天
2. 保存
3. 立即点击"触发限流"
4. 3天后自动解封

### 场景 3：紧急解封

**背景**：
- 模型被限流了
- 限额已恢复，想立即解封

**操作步骤**：
1. 找到限流的模型
2. 点击"解封"按钮
3. 立即恢复可用状态

---

## 🔧 技术实现

### 关键函数

#### 1. `triggerCooldown(row)`
触发限流，应用规则：

```javascript
async function triggerCooldown(row) {
  if (!row.hasRule) {
    ElMessage.warning('该后端未配置限流规则')
    return
  }
  
  const rule = row.rule
  const current = backendState.value[row.key]?.unblockAt
  const unblockAt = computeUnblockAt(rule.type, rule.value, current)
  
  await gateway.setBackendCooldown(row.key, unblockAt)
  await load()
  ElMessage.success('已触发限流')
}
```

#### 2. `saveBackend()`
保存配置，包含规则：

```javascript
async function saveBackend() {
  // ...
  const entry = { provider, model }
  
  // 保存限流规则（不触发）
  if (form.value.cooldownEnabled) {
    entry.cooldownRule = {
      type: form.value.cooldownType,
      value: ruleValue
    }
  }
  
  config.value.backends[editIndex.value] = entry
  await gateway.saveConfig(toRaw(config.value))
  // ...
}
```

#### 3. `backendStatus(b)`
检查状态：

```javascript
function backendStatus(b) {
  const key = backendKey(b)
  const s = backendState.value[key]
  
  // 只看 backend-state.json，不看规则
  if (!s?.unblockAt) return { status: 'active', unblockAt: null }
  
  const at = new Date(s.unblockAt).getTime()
  if (Number.isNaN(at) || at <= Date.now()) {
    return { status: 'active', unblockAt: null }
  }
  
  return { status: 'cooldown', unblockAt: s.unblockAt }
}
```

### 数据流

```
┌─────────────────────────────────────────────────────┐
│                    用户操作                         │
└────────────┬────────────────────────────────────────┘
             │
             ▼
    ┌────────────────────┐
    │ 编辑对话框配置规则 │
    └────────┬───────────┘
             │
             ▼
    ┌────────────────────┐
    │  保存到 providers  │  ← 规则存储
    │   .json 的 backends│
    └────────┬───────────┘
             │
             │ （模型仍然可用）
             │
             ▼
    ┌────────────────────┐
    │ 模型被 API 限流    │  ← 触发条件
    └────────┬───────────┘
             │
             ▼
    ┌────────────────────┐
    │ 点击"触发限流"    │  ← 手动触发
    └────────┬───────────┘
             │
             ▼
    ┌────────────────────┐
    │ 根据规则计算时间   │  ← computeUnblockAt()
    └────────┬───────────┘
             │
             ▼
    ┌────────────────────┐
    │ 保存到 backend-    │  ← 状态存储
    │  state.json        │
    └────────┬───────────┘
             │
             ▼
    ┌────────────────────┐
    │ UI 显示"限流至XX" │  ← 状态显示
    └────────────────────┘
```

---

## 🆚 新旧对比

| 功能 | 旧版本（错误） | 新版本（正确） |
|------|----------------|----------------|
| 配置限流 | 立即生效，模型不可用 | 只保存规则，模型仍可用 |
| 触发方式 | 保存时自动触发 | 需要手动点击"触发限流" |
| 规则存储 | 直接写入 state | 分开存储：规则在 config，状态在 state |
| 解封 | 删除规则 | 只清除状态，规则保留 |
| 再次限流 | 需要重新配置规则 | 规则保留，直接点击触发 |

---

## ⚠️ 注意事项

### 1. 规则和状态的区别

- **规则**：可以理解为"预案"，配置好待用
- **状态**：真正生效的限流，影响可用性

**不要混淆**：
- 配置规则 ≠ 触发限流
- 删除后端 = 删除规则和状态
- 解封 = 只清除状态，规则保留

### 2. 触发限流的时机

建议在以下情况触发：
- ✅ API 返回 429（Too Many Requests）
- ✅ API 返回限流相关错误
- ✅ 手动观察到模型不可用
- ❌ 不要预先触发（没有意义）

### 3. 规则的修改

- 修改规则**不影响**已触发的限流状态
- 如需立即应用新规则：
  1. 先解封
  2. 保存新规则
  3. 重新触发限流

---

## 🔮 未来增强

可能的功能扩展：

1. **自动触发**
   - 监听后端 API 返回
   - 自动检测 429 错误
   - 自动应用规则

2. **规则模板**
   - 预设常见服务商的规则
   - 一键应用

3. **限流历史**
   - 记录每次限流的时间
   - 统计限流频率

4. **批量操作**
   - 批量触发限流
   - 批量解封

---

## ✅ 总结

### 新的限流机制优势

1. **灵活性**：规则和状态分离，可以预先配置
2. **可控性**：手动触发，不会误操作
3. **可复用**：规则保留，下次直接触发
4. **清晰性**：UI 明确显示规则和状态

### 使用建议

1. **提前配置**：为所有后端配置好规则
2. **按需触发**：只在真正限流时触发
3. **及时解封**：限额恢复后立即解封
4. **定期检查**：刷新状态，查看是否自动解封

**现在限流机制更符合实际使用场景，享受更好的管理体验！**
